Welcome to the Standard Template Library(i.e., STL) section of the course. In this section of the course, we'll learn about the c++ Standard Template Library or STL for short. The STL provides a rich set of containers, iterators and algorithms that we can use with just about any type of data we wish. We've already worked with one of the STL workhorses i.e., the vector. First, we'll see what the STL is all about, and then we'll learn a little bit about generic or meta programming, which is what the STL uses to allow us to use its components on just about any type of data. We'll see how c++ can use preprocessor macros, function templates and class templates to achieve generic programming. We'll also learn what generic programming is and why it's so powerful. Then we'll look at the types of containers, iterators and algorithms provided by the STL. And we'll look at each of the main containers such as array, vector, deque, list, set, map, stack, queue and priority queue. Finally, we'll learn about some of the commonly used algorithms in the STL. The cool thing about the STL is that once you learn how to use one container, one iterator and one algorithm, then the rest follows the same pattern, so they become easy to learn. There will also be several challenges in this section that will allow you to solve more problems using the STL containers, iterators and algorithms. Most beginning c++ courses don't cover the STL but I think it's important to cover it since it's used very often in c++ programming. Great. So let's see what the STL is all about.

I'd like to give an overview of the basic elements of the c++ Standard Template Library and see what it's all about. The STL is a library of powerful, reusable, adaptable, generic classes and functions. So what do all those words mean. Well, the STL is powerful. We've already seen a bit of that power when we use the vector class. The STL is reusable. Remember, when we created vector of integers or doubles or Accounts and so forth, we didn't have to do anything except tell the vector what we wanted it to hold. The STL is adaptable. It provides containers, iterators and algorithms that we can adapt to make them do whatever we need them to do with our programs. Finally, the STL is implemented using template functions and template classes. We'll learn about c++ templates in the next few videos. They're one of the features that makes c++ so powerful. The STL is a huge class library. We'll only be scratching the surface in this section. But once you understand how to use the STL, the principles we'll learn will apply across the entire STL. The STL was developed around 1994 by Alexander Stepanov, and even today is considered one of the best designed generic class libraries ever created.

So what is the STL? Well, at its core, the STL is an assortment of commonly used containers. We'll see some of these containers later. The algorithms provided by the STL have published and well understood time and size complexity information. That means that when you use the containers and algorithms in the STL, there are no surprises. You know exactly how the algorithms behave as the size of the collection increases. Complexity theory is beyond the scope of this course, but it's an important part of software development. The STL has been around for a long time. It's been tried and tested across many millions of lines of code. The STL is consistent, fast, type safe as well as extensible.

The STL has three main components: containers, algorithms and iterators. Containers are collections of objects or primitive types. These include array, vector, deque, stack, set, map and more. Algorithms are functions for processing sequence of elements from containers. The STL has about 60 algorithms that can be used and extended to work with any type of data. These algorithms allow us to find a specific element in a container, find the max or min element in a container, count the number of elements in a container, accumulate or sum up the values of container elements, sort containers, etc. And that's just a few examples, we can do much much more. Finally, iterators generate the sequences of elements from the containers that the algorithms use. There are several types of iterators that allow us to generate sequences of elements in various ways. Note that one of the beautiful aspects of the design of the STL is that the containers, algorithms and iterators are designed totally independently from one another. Yet, they work together seamlessly. Also note that I said the STL has three main components. It also has a few other components such as functors and allocators, but we won't be covering those in this section.

Before we get into the details of the STL, let's see a simple example of how we could use some of its functionality. We'll use a vector of integers for these examples, as shown below, since we're already familiar with vectors. In this example, I'm including the <vector> and <algorithm> header files. <vector> header file allows me to work with vectors and <algorithm> header file allows me to use the STL algorithms. So let's create a simple vector of integers. We'll call it 'v', and initialize it with three integers i.e., 1, 5 and 3.
	#include <vector>
	#include <algorithm>

	std::vector<int> v {1,5,3};

Now suppose we want to sort that vector(i.e., v). We can use the STL 'sort' algorithm to do that, as shown below, but the 'sort' algorithm needs a sequence of objects to sort. That's where the iterator comes in. We provide the sequence using v.begin() and v.end(). This provides the 'sort' algorithm with the integers in the vector v from the beginning element to the ending element, in other words, the entire vector. Now we can display the vector using a range-based for loop, and we can see the elements in the vector are now sorted.
	std::sort(v.begin(), v.end());

	for (auto elem: v)
		std::cout << elem << std::endl;

The iterator, which we used above, produced a sequence of all the integers in the vector, but we could have easily provided only a subset if that's what we needed. So suppose we had a need to only sort the first half of a vector, we could modify the iterator to produce just the first half of the elements. Also we aren't restricted to using a vector only. We can sort just about any STL container exactly the same way. Also, we can extend the 'sort' algorithm to tell it exactly how to compare the elements when sorting. For example, maybe we have a vector of Account(i.e., user defined type) objects, and we want to sort them by balance.
	std::reverse(v.begin(), v.end());

	for (auto elem: v)
		std::cout << elem << std::endl;

Suppose that now we want to reverse the order of the integers in this vector v. We can use the STL 'reverse' algorithm to do that, as shown above. The code is exactly the same, but we use the 'reverse' function instead of 'sort'. And when we display the vector's elements, we get 5 -> 3 -> 1, as we expect. Also, I should mention that behind the scenes, the range based for loop is itself an iterator. We'll talk more about that later.
	int sum{};

	sum = std::accumulate(v.begin(), v.end(), 0);
	std::cout << sum << std::endl;

Now let's see a different type of algorithm function i.e., the 'accumulate' function. In this case, I want to add up all the integers in the vector and store the result in a variable called sum. To do this, I can use the 'accumulate' function. Notice that the 'accumulate' function has parameters. The first two parameters are iterators: where do I start, where do I end. This produces the sequence of elements that the 'accumulate' function will process. The third parameter, 0 in this case, is what the running sum will start at, typically 0, but we can use any number. Remember the type of this third parameter is very important. So if you want to sum integers, use 0. If you want to sum doubles, use 0.0, the total is stored in 'sum' variable and in this case we display 9, which is 1+3+5, the sum of the elements in the vector. From these simple examples, you can see how powerful using containers, iterators and algorithms can be.

Now let's talk about the various types of containers provided by the STL. We have three basic categories of containers: Sequence, Associative and Container Adapters. Sequence containers are containers that maintain the ordering of inserted elements. These containers include array, vector, list, forward_list and deque. We'll discuss each of these containers in this section of the course. Associative containers insert elements in a predefined order or no order at all. For example, a set is a collection of elements where there are no duplicates, but there may be an order associated with it or not. A map is like a dictionary, where we associate a word with its definition. There are many variants of this category. So we can have ordered sets, unordered sets, sets that allow duplicates, maps that allow duplicates and so forth. These are very powerful data structures that are often underused. We'll talk about them in this section and I'll show you how to use them. The last category container adapters are variations of the other containers. This category does not support iterators, so they can't be used with STL algorithms, but they're so commonly used in programming that the STL provides support for them. These include the stack, the queue and the priority queue.

Now, you can see that the STL has several types of iterators. Input iterators make container elements available to your program. Output iterators can iterate over a sequence and write an element to a container. Forward iterators can iterate forward over a sequence and can read or write any element. Bi-directional iterators are like forward iterators, but they can iterate over a sequence in both directions. And finally, random access iterators can use the subscript operator/notation to directly access elements. We saw that with the vector class.

Finally, we have the STL algorithms. As I mentioned previously, there are about 60 algorithms in the STL. And the algorithms are classified into two major groups: non-modifying and modifying algorithms, depending on whether the algorithm modifies the sequence it acts upon. As you can see, there is a lot to the STL, and we can't possibly cover it all in detail in a single section. In fact, entire books have been written about the STL, but, by the time you get to the end of this section, you'll understand the fundamentals of the STL and be able to use STL containers, iterators and algorithms to solve real problems. But before we get to the STL, let's talk a little bit about generic programming and templates so that we can understand the design behind the STL.
