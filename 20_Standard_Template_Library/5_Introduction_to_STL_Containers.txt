I'd like to go over some of the basics of the standard template library containers. We won't go over the details of specific containers in this video, we'll get to that soon enough. Instead, it's important to understand what the containers have to offer as far as functionality is concerned and understand what types of elements we can store in them. First, we know that the STL containers are data structures that can store almost any type of object, and they're implemented as template-based classes. Each container has a set of member functions that we can use. Some of these member functions are specific to a particular container. But there are quite a few member functions that all containers implement. We'll go over a table with some of these methods in the next few slides. Finally, each container has an associated header file that must be included in order to use the container. We've already seen this with vector and string. I'll tell you what the specific header file is for each container class we go over.

So let's take a look at some of the common methods provided by the STL containers. This table and the table on the next slide(see the page number 787 of LPA-Beginning-C++-Programming-From-Beginner-to-Beyond-SEP2024.pdf) show some of the functionality provided by the STL containers. Let's start with the default constructor. All containers provide default constructors and it results in an empty container. They also provide many versions of overloaded parameterized constructors that allow you to initialize the containers in many ways. You have to refer to the specific container you want to use to see the various overloaded constructors. Containers also provide copy and move constructors. So we can create a new container based on an existing container. We can choose to copy it or move it. Ofcourse, containers provide destructors. The container destructors clean up the container and delete all the objects in it. Containers also provide overloaded copy and move assignment operator. This, ofcourse, will allow you to copy or move an existing container into another existing container. Remember, this is not initialization. Also, containers provide the last three methods(i.e., size, empty and insert) in the table which are used very often. size returns the number of elements in the container, empty returns true or false depending on whether the container is empty or not, and the insert method allows us to insert an element into a container.

In the next table(see the next slide), we can see that we also have the ability to compare two containers. We can test to see if the elements of one container are less than(i.e., <) the elements of a second container and we can also test for less than or equal to(i.e., <=), greater than(i.e., >) and greater than or equal to(i.e., >=). We can also check to see if the contents of two containers are the same or not, using the equality operators. We have the swap function, which swaps the elements of two containers. And we can remove one or all elements from a container using erase and clear functions. And finally, we can get iterators(begin and end, rbegin and rend, cbegin and cend, crbegin and crend) to elements in containers. Not all containers support all these iterators but I listed them anyway so you could see them here. We'll talk about iterators in more detail in the next video. So don't worry, you'll learn about them in a few minutes.

Now that we know a little bit more about the functionality provided by containers, let's talk about what types of objects we can store in containers. First, we can store all of the primitive types in containers, int, float, double, all of them. But what about our objects. It's important to remember that when we store an element in a container, the container makes a copy of that element. So we must be sure that our objects are copyable and assignable. This means they must have default copy constructor or our own copy constructor, as well as overloaded copy assignment operator. We can also provide move semantics(i.e., move Constructor and overloaded move Assignment operator) for efficiency. Finally, the ordered associative containers must be able to compare objects. They do this using the less than(i.e., <) and the equality(i.e., ==) operators. So your objects must support these operators via operator overloading. Now, I hope you can see that everything we've learned and done in this course comes together right here. We now know exactly what we have to do to make our own objects work with the STL. And you know what, it's not that complicated. In most cases, we can use all of the compiler provided functionality unless we have raw pointers and we already learned how to handle classes with raw pointers.
