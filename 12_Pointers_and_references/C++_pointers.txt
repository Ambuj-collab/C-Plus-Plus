Before we get into any c++ code that uses pointers, let's see what a pointer is. A pointer is a variable. We know all about variables. Variables have an address in memory where they're bound to. They also have a type, such as int, double, string, vector and so forth. And they have a value, which they store. A pointer is a variable and it stores the address of another variable or function. So if I initialize an integer variable named x to 10 then x is of type integer and it's bound to some memory location, and it contains the value 10. That means that I can declare a pointer variable that stores the address of x. So a pointer is a variable. That means that the pointer has a memory location where it's bound to. It has a type, it has a value, and the value is an address. We'll see how to declare a pointer in c++ later. Remember that a pointer points to a variable or to a function. To use the pointer, you must know the type of what it points to. Before we learn about how to use pointers, let's see why we use pointers in the first place. If a pointer points to a variable or a function, can't I just use the variable or the function directly? Sure, and if you can then you should. There is no sense in creating a pointer to something that you can use directly, but you can't always do that. For example, if you have some complex data that's defined outside a function and you want to access that data from within the function, you can't because the variable name is out of scope. So you can pass the data to the function by value and make a copy of it or you can use a reference(i.e., a pointer parameter) to access that data from within the function. Also pointers are often used to operate on arrays very efficiently. In fact, we'll see in this section just how pointers and arrays are interrelated. We can use pointers to allocate memory from the heap or the free store dynamically at runtime, that memory doesn't have a variable name associated with it. So the only way to use it is through a pointer. Finally, if you're working with embedded systems, device drivers or other types of system software, sometimes you need to gain access to a specific memory address or a range of memory addresses. Pointers is the best way to do that.

Just like all variables, if we don't initialize our pointer variables, they will contain garbage data. In c++, it's very important that you always initialize all pointer variables before you use them. If you don't initialize a pointer variable, it will have garbage data. In this case, that garbage data represents an address since that's what a pointer contains. So you can think of an uninitialized pointer as pointing anywhere. So if we use it, we could be accessing memory that we have no business messing around with. We don't even know what that memory is.
	int *ptr {};	OR	int *ptr {nullptr};

In these examples, we're initializing the pointer variables to zero, that's what null pointer represents. This means that we're initializing the pointers to point nowhere. That's very different from pointing anywhere. nullptr was introduced in c++11, and it represents address 0, which means that the pointer is pointing nowhere. Use nullptr to initialize your pointers unless you initialize them to a variable or to a function, this nulls out the pointer.

Let's see how to access the data that a pointer is pointing to. In order to access the data that a pointer is pointing to, we need to follow the pointer to where it's pointing. This is called dereferencing the pointer. * is dereferencing or indirection operator.

So now that we understand the basics of c++ pointers. Let's talk about one of the main use cases for pointers that is dynamic memory allocation. When we're developing software, we often have no idea how much storage we're going to need to model our data. For example, if I'm modeling the students in my class, how many students do I allocate storage for. If I'm using an array to model the students, then I need to know exactly how many students I have, since once I allocate an array it's fixed in size. I know what you're thinking, hey, didn't you tell us earlier that we should be using vectors instead of arrays. Yes, I did. And that's still true. However, it's important to understand how to allocate memory dynamically, not just for arrays but for other data, including objects. Also, how do you think vectors work behind the scenes? They use techniques to allocate and deallocate memory from the heap. So we really need to understand how that works. When you allocate storage in this manner, the storage is on the heap, the allocated storage contains garbage data until you initialize it. The allocated storage does not have a name. The only way to get to that storage is via the pointer. If you lose the pointer because it goes out of scope or you reassign it, then you lost your only way to get to that storage and you have a memory leak. Finally, when you're done using the allocated storage, then you must de-allocate the storage, so that it's again available to the rest of the program.

It's critical that you understand the relationship between arrays and pointers in c++. Remember that the value of an array name is the location or the address of the first element of the array, and the value of a pointer is an address. So if a pointer points to the same type of data, as the array elements, then the pointer and the array name are the same as far as c++ is concerned. The only difference is that the array name is not a variable, so you can't change it. But otherwise, all the calculations done to access array elements can be done with the array name or the pointer name.
